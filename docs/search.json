[{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"analysis-of-blastic-plasmacytoid-dendritic-cell-neoplasm-bpdcn","dir":"Articles","previous_headings":"","what":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":", compare analysis cells patient BPDCN. original script available : https://github.com/petervangalen/MAESTER-2021/blob/main/4_CH_sample/4.2_Variant_Selection.R setup, cells single donor separated categories. small clones might characterize clonal lineages sample selected.","code":""},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"loading-necessary-packages-","dir":"Articles","previous_headings":"","what":"Loading necessary packages.","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"load data MAESTER.","code":"print(\"Libraries for SIGURD.\") ## [1] \"Libraries for SIGURD.\" suppressPackageStartupMessages(library(sigurd)) suppressPackageStartupMessages(library(SummarizedExperiment)) suppressPackageStartupMessages(library(ggplot2))"},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"loading-the-data-using-sigurd-","dir":"Articles","previous_headings":"","what":"Loading the data using SIGURD.","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"","code":"# The design matrix contains information for the genotyping data. genotyping <- LoadingMAEGATK_typewise(patient = \"BPDCN712\", samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/MAESTER_Reproduction.csv\", type_use = \"Amplicon_MT\", verbose = FALSE)  # Loading the scRNA-seq data. scrna <- readRDS(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/BPDCN712_Seurat_with_TCR_Renamed.rds\")"},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"generating-a-block-list","dir":"Articles","previous_headings":"","what":"Generating a block list","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"Variants also detected cell mixture data treated possible false positives. used blacklist removed results.","code":"# Loading the TenX Cell Mixture Genotyping.  genotyping_tenx <- load_object(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/TenX_CellMixture_Genotyping.rds.lz4\") blocklist <- AllelFrequencyFoldChange(genotyping_tenx, group_of_interest = \"CellType\", group1 = \"K562\", group2 = \"BT142\", maximum_foldchange = 5, minimum_coverage = 5, minimum_allele_freq = 0.001, maximum_allele_freq = 0.999)$Variant  # We add the variant chrM_1583_A_G by hand. It is identified as misleading based on downstream analysis. blocklist <- c(blocklist, \"chrM_1583_A_G\")"},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"selecting-the-variants-of-interest","dir":"Articles","previous_headings":"","what":"Selecting the Variants of Interest","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"Now, select variants interest loaded data.","code":"voi.ch.sigurd <- VariantSelection_TopCells(genotyping, min_coverage = 5, quantiles = 0.9, thresholds = 0, top_cells = 10, top_VAF = 0.5, min_quality = 30, remove_nocall = FALSE, verbose = FALSE) voi.ch.sigurd <- voi.ch.sigurd[!voi.ch.sigurd %in% blocklist] print(voi.ch.sigurd) ##  [1] \"chrM_683_G_A\"   \"chrM_1323_G_A\"  \"chrM_1415_G_A\"  \"chrM_2593_G_A\"  ##  [5] \"chrM_6205_G_A\"  \"chrM_6243_G_A\"  \"chrM_8697_G_A\"  \"chrM_9753_G_A\"  ##  [9] \"chrM_10158_T_A\" \"chrM_15140_G_A\" \"chrM_15812_G_A\" \"chrM_779_T_C\"   ## [13] \"chrM_3988_T_C\"  \"chrM_6185_T_C\"  \"chrM_6293_T_C\"  \"chrM_9164_T_C\"  ## [17] \"chrM_9321_T_C\"  \"chrM_11864_T_C\" \"chrM_15299_T_C\" \"chrM_1171_A_G\"  ## [21] \"chrM_1222_A_G\"  \"chrM_2241_A_G\"  \"chrM_2623_A_G\"  \"chrM_3628_A_G\"  ## [25] \"chrM_4104_A_G\"  \"chrM_6218_A_G\""},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"visualisation-using-sigurd","dir":"Articles","previous_headings":"","what":"Visualisation using SIGURD","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"","code":"genotyping <- Filtering(SE = genotyping, cells_include = colnames(scrna)) ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We remove all the variants that are always NoCall.\" colData(genotyping)$CellType <- scrna$CellType HeatmapVoi(SE = genotyping, voi = voi.ch.sigurd, annotation_trait = \"CellType\", sort_cells = TRUE, remove_empty_cells = TRUE, minimum_allele_freq = 0.01)"},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"cell-type-enrichment-2593ga","dir":"Articles","previous_headings":"","what":"Cell Type Enrichment 2593G>A","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"check cell type enrichment variant 2593G>.","code":"result_enrichment <- Enrichment_FisherTest(se = genotyping, variant = \"chrM_2593_G_A\", use_nocall = FALSE, trait = \"CellType\") ## [1] \"We get a count matrix of the chrM_2593_G_A per CellType.\" ComplexHeatmap::Heatmap(as.matrix(result_enrichment$Heatmap_Values), cluster_rows = FALSE, cluster_columns = FALSE, col= circlize::colorRamp2(c(0, max(result_enrichment$Heatmap_Values, na.rm = TRUE)), c(\"white\", \"red\")))"},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"cell-type-enrichment-6243ga","dir":"Articles","previous_headings":"","what":"Cell Type Enrichment 6243G>A","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"check cell type enrichment variant 6243G>.","code":"result_enrichment <- Enrichment_FisherTest(se = genotyping, variant = \"chrM_6243_G_A\", use_nocall = FALSE, trait = \"CellType\") ## [1] \"We get a count matrix of the chrM_6243_G_A per CellType.\" ComplexHeatmap::Heatmap(as.matrix(result_enrichment$Heatmap_Values), cluster_rows = FALSE, cluster_columns = FALSE, col= circlize::colorRamp2(c(0, max(result_enrichment$Heatmap_Values, na.rm = TRUE)), c(\"white\", \"red\")))"},{"path":"https://costalab.github.io/sigurd/articles/BoneMarrow_SIGURD.html","id":"enrichment-with-somatic-variants","dir":"Articles","previous_headings":"","what":"Enrichment with somatic variants","title":"Analysis of Blastic Plasmacytoid Dendritic Cell Neoplasm (BPDCN)","text":"get number 2593_G>cells also mutated different somatic variant.","code":"somatic_variants <- c(\"ASXL1.G642fs.1\", \"ASXL1.G642fs.2\", \"TET2.S792X\", \"TET2.Q1034X\", \"TET2.R1216X\", \"TET2.H1380Y\") variants <- LoadingRawMatrix_typewise(samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/MAESTER_Reproduction.csv\", patient = \"BPDCN712\", variant_use = somatic_variants, matrix_column_separator = \"\\t\", verbose = FALSE) genotyping <- genotyping[voi.ch.sigurd, ] genotyping <- Filtering(genotyping, cells_include = colnames(variants)) ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We remove all the variants that are always NoCall.\" variants <- Filtering(variants, cells_include = colnames(scrna), fraction_threshold = 0.01, reject_value = \"Reference\") ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We assume that cells with a fraction smaller than our threshold are actually Reference.\" ## [1] \"We set consensus values to 1 (Reference) and fraction values to 0.\" ## [1] \"We do not set fractions between 0.01 and 1 to 1.\" ## [1] \"This way, we retain the heterozygous information.\" ## [1] \"We remove all the variants that are always NoCall.\" genotyping <- CombineSEobjects(se_1 = genotyping, se_2 = variants) genotyping <- ClonalDefinition(se = genotyping, variants_ls = list(\"chrM_2593_G_A\"), grouping = NULL, identities = NULL, explicit = TRUE, explicit_not = list(\"chrM_6243_G_A\"), explicit_min_vaf = 0.01, verbose = TRUE) ## [1] \"Explicit clone definition.\" genotyping <- genotyping[, genotyping$Clones == \"C1\"] res <- VariantWiseFisherTest(variants_list = RowWiseSplit(se = genotyping)) ## [1] \"Testing Variant: ASXL1.G642fs.1, 1 out of 6\" ## [1] \"Testing Variant: ASXL1.G642fs.2, 2 out of 6\" ## [1] \"Testing Variant: TET2.S792X, 3 out of 6\" ## [1] \"Testing Variant: TET2.Q1034X, 4 out of 6\" ## [1] \"Testing Variant: TET2.R1216X, 5 out of 6\" ## [1] \"Testing Variant: TET2.H1380Y, 6 out of 6\" ## [1] \"We remove the NA P values.\" ## [1] \"Adjusting P values using fdr.\" knitr::kable(res, format=\"html\")"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"loading-necessary-packages-","dir":"Articles","previous_headings":"","what":"Loading necessary packages.","title":"Analysis of MPN Data","text":"","code":"suppressPackageStartupMessages(library(sigurd)) suppressPackageStartupMessages(library(SummarizedExperiment)) suppressPackageStartupMessages(library(ggplot2)) suppressPackageStartupMessages(library(Seurat)) suppressPackageStartupMessages(library(ComplexHeatmap)) suppressPackageStartupMessages(library(circlize)) suppressPackageStartupMessages(library(grid)) suppressPackageStartupMessages(library(EnhancedVolcano))"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"analysis-of-mpn-data","dir":"Articles","previous_headings":"","what":"Analysis of MPN data","title":"Analysis of MPN Data","text":", illustrate analysis genotyping data MPN samples. JAK2V617F mutation genotyped 6 MPN samples 3 healthy controls. setup makes analysis different previous analyses. Previously, one sample analysed time. Now, load analyse samples simultaneously.","code":""},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"loading-mpn-data","dir":"Articles","previous_headings":"","what":"Loading MPN data","title":"Analysis of MPN Data","text":"Now, load JAK2V617F data plot mutated cells UMAP. Since loading multiple samples, code complicated code MAESTER SW sample.","code":"# Loading the scRNA-seq data. scrna <- load_object(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/Paper_Figures/ZenodoFiles/Zenodo_Seurat_Object.rds\")  # Loading the genotyping data. # genotyping  <- LoadingVarTrix_typewise(patient = \"MPN\", samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/DesignMatrix_VarTrix.csv\", min_reads = 0, vcf_path = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd_v2/inst/extdata/JAK2V617F.vcf\", type_use = \"scRNAseq_Somatic\", min_cells = 0, verbose = FALSE) # amplicon <- LoadingVarTrix_typewise(patient = \"MPN\", samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/DesignMatrix_Amplicon.csv\", min_reads = 0, vcf_path = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd_v2/inst/extdata/UCSC_JAK2V617F.vcf\", type_use = \"scRNAseq_Amplicon\", min_cells = 0, verbose = FALSE) # genotyping  <- AmpliconSupplementing(scRNAseq = genotyping, amplicon = amplicon, verbose = FALSE)  # Filtering the genotyping object to remove false positives. # genotyping <- Filtering(genotyping, min_cells_per_variant = 0, fraction_threshold = 0.21, cells_include = colnames(scrna), min_variants_per_cell = 1, reject_value = \"NoCall\", verbose = FALSE)  # We load the provided genotyping object. genotyping <- load_object(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/MPN_JAK2V617F_Genotyping.rds\")"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"combining-seurat-and-sigurd","dir":"Articles","previous_headings":"","what":"Combining Seurat and SIGURD","title":"Analysis of MPN Data","text":"Now, add genotyping information Seurat object.","code":"scrna <- SetVariantInfo(SE = genotyping, seurat_object = scrna) ## [1] \"You did not supply a vector of variants. All variants will be used.\""},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"visualisation","dir":"Articles","previous_headings":"","what":"Visualisation","title":"Analysis of MPN Data","text":"visualize genotyping information UMAP.","code":"# Plotting the mutated cells on the UMAP. scrna$JAK2_p.V617F_c.1849G.T_consensus <- factor(scrna$JAK2_p.V617F_c.1849G.T_consensus, levels = c(\"Ref\", \"Alt\")) jak2_cells <- sum(scrna$JAK2_p.V617F_c.1849G.T_consensus == \"Alt\", na.rm = TRUE) ref_cells <- sum(scrna$JAK2_p.V617F_c.1849G.T_consensus == \"Ref\", na.rm = TRUE) all_cells <- ncol(scrna) p <- DimPlot(scrna, group.by = \"JAK2_p.V617F_c.1849G.T_consensus\", reduction = \"INTE_UMAP\", order = TRUE, pt.size = 1, raster = FALSE, na.value = \"grey95\", cols = c(Alt = \"#aa0051\", Ref = \"#79b938\")) +   ggtitle(paste0(\"Alt: \", jak2_cells, \", Ref: \", ref_cells, \", All: \", all_cells)) +   xlab(\"UMAP 1\") + ylab(\"UMAP 2\") + scale_color_manual(breaks = c(\"Alt\", \"Ref\"), values = c(\"#aa0051\", \"#79b938\"), na.value = \"grey95\") +   theme(legend.position = \"top\") ## Scale for colour is already present. ## Adding another scale for colour, which will replace the existing scale. print(p)"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"we-determine-degs-between-the-jak2v617f-and-wt-cells-","dir":"Articles","previous_headings":"","what":"We determine DEGs between the JAK2V617F and WT cells.","title":"Analysis of MPN Data","text":"Now, determine DEGs JAK2V617F cells wild type cells Orthochromatic Erythroblasts.","code":"scrna_orthoe <- subset(scrna, celltype == \"Orthochromatic Erythroblasts\" & condition != \"HC\") degs <- FindMarkers(scrna_orthoe, group.by = \"JAK2_p.V617F_c.1849G.T_consensus\", ident.1 = \"Alt\", ident.2 = \"Ref\", logfc.threshold = 0) degs <- data.frame(degs, gene = rownames(degs)) degs_up   <- nrow(subset(degs, avg_log2FC >   0.25 & p_val_adj < 0.05)) degs_down <- nrow(subset(degs, avg_log2FC <  -0.25 & p_val_adj < 0.05)) EnhancedVolcano(degs, x = \"avg_log2FC\", y = \"p_val_adj\", lab = degs$gene, FCcutoff = 0.25, pCutoff = 0.05, title = \"OrthoE JAK2V617F Pos. vs. Neg.\",subtitle = NULL)"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"combining-the-jak2v617f-data-with-the-mt-data-","dir":"Articles","previous_headings":"","what":"Combining the JAK2V617F data with the MT data.","title":"Analysis of MPN Data","text":"combine JAK2V617F SIGURD object MT object. Cells variants objects combined. save time, processing single sample. samples processed equally. Since genotyping object list, easily processed using parallel computing. First, load filter mitochondrial variant information.","code":"# Loading the data.  # genotyping_mt <- LoadingMAEGATK_typewise(patient = \"MPN1\", samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/DesignMatrix_MT.csv\", min_cells = 0, cells_include = colnames(scrna), type_use = \"scRNAseq_MT\", verbose = FALSE) # genotyping_mt <- Filtering(genotyping_mt, min_variants_per_cell = 1, min_cells_per_variant = 2, fraction_threshold = 0.05, cells_include = colnames(scrna), verbose = FALSE) # Adding the JAK2V617F information. # genotyping_MPN1 <- Filtering(genotyping, cells_include = grep(\"MPN1\", colnames(genotyping), value = TRUE)) # genotyping_mt <- CombineSEobjects(genotyping_MPN1, genotyping_mt)  # We load the Zenodo File. This is equivalent to the way we do it above.  genotyping_mt_all <- load_object(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/Paper_Figures/ZenodoFiles/scrna_genotyping.rds\") genotyping_mt <- genotyping_mt_all[[\"MPN1\"]] genotyping_mt <- Filtering(genotyping_mt, min_variants_per_cell = 1, min_cells_per_variant = 2, fraction_threshold = 0.05, cells_include = colnames(scrna), verbose = FALSE)"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"mpn-vois-and-diversity","dir":"Articles","previous_headings":"","what":"MPN VOIs and Diversity","title":"Analysis of MPN Data","text":"Now, select mtVOIs. determine clonal lineages plot results heatmap. subset cells include erythroid cells.","code":"# Subset to erythroid cells. erythroid_cells <- colnames(subset(scrna, celltype_merged == \"ErythroidCells\")) genotyping_mt <- Filtering(genotyping_mt, cells_include = erythroid_cells) ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We remove all the variants that are always NoCall.\" # Selecting the mtVOIS. mt_vois <- VariantSelection_Quantile(genotyping_mt, min_coverage = 1, verbose = FALSE)  # Determining the clonal lineages. genotyping_mt <- ClonalDefinition(se = genotyping_mt, variants_ls = list(mt_vois), verbose = FALSE)"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"visualisation-of-mtvois-and-clonal-lineages","dir":"Articles","previous_headings":"","what":"Visualisation of mtVOIs and Clonal Lineages","title":"Analysis of MPN Data","text":"now plot variants interest clonal lineages.","code":"# Generating a heatmap. colors_lineage <- c(\"C1\" = \"#563e00\", \"C2\" = \"#dec234\", \"C3\" = \"#e23856\", \"C4\" = \"#7f0073\", \"C5\" = \"#006639\", \"C6\" = \"#b1db8e\", \"C7\" = \"#00348f\", \"Negative\" = \"black\") ha <- columnAnnotation(Clones = colData(genotyping_mt)[,\"Clones\"],                        col = list(Clones = colors_lineage),                        annotation_name_gp = gpar(fontsize = 10, fontface = \"plain\"),                        annotation_legend_param = list(Clones = list(nrow = 1, title = \"\"))) fraction <- as.matrix(assays(genotyping_mt)[[\"fraction\"]])[mt_vois, ] hm <- Heatmap(fraction,   name = \"VAF\",   row_title_gp = gpar(fontsize = 12),   row_names_gp = gpar(fontsize = 10),   row_names_max_width = unit(16, \"cm\"),   column_title = \"MPN1\",   column_title_gp = gpar(fontsize = 12),   column_names_gp = gpar(fontsize = 10),   col = colorRamp2(seq(0, round(max(fraction, na.rm = TRUE)), length.out = 9), c(\"#FCFCFC\", \"#FFEDB0\", \"#FFDF5F\", \"#FEC510\", \"#FA8E24\", \"#F14C2B\", \"#DA2828\", \"#BE2222\", \"#A31D1D\")),   show_column_dend = FALSE,   show_row_names = TRUE,   show_column_names = FALSE,   cluster_columns = TRUE,   cluster_rows = FALSE,   heatmap_legend_param = list(border = \"#000000\", grid_height = unit(10, \"mm\"),   direction = \"horizontal\"),   bottom_annotation = ha,   border = TRUE,   use_raster = TRUE,   show_heatmap_legend = TRUE) draw(hm, annotation_legend_side = \"bottom\")"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"calculating-clonal-diversity-","dir":"Articles","previous_headings":"","what":"Calculating clonal diversity.","title":"Analysis of MPN Data","text":"calculate clonal diversity sample MPN1 example.","code":"clonal_diversity <- ClonalDiversity(genotyping_mt, grouping = \"Clones\", diversity_measure = \"EffectiveSpecies\", verbose = FALSE) print(paste0(\"Clonal Diversity in Effective Number of Species for MPN1: \", clonal_diversity)) ## [1] \"Clonal Diversity in Effective Number of Species for MPN1: 6.72545022391521\""},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"repeating-the-mt-analysis-for-all-samples-","dir":"Articles","previous_headings":"","what":"Repeating the MT analysis for all samples.","title":"Analysis of MPN Data","text":"now repeat MT analysis samples. take considereable time. speed analsyis using parallel computing. Since Zenodo file already loaded, save time .","code":"# We get all patients present in the design matrix. design_matrix <- read.table(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/DesignMatrix_MT.csv\", header = TRUE, sep = \",\") patients <- design_matrix$patient # genotyping_mt_all <- parallel::mclapply(patients, LoadingMAEGATK_typewise, samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/DesignMatrix_MT.csv\", min_cells = 0, cells_include = colnames(scrna), type_use = \"scRNAseq_MT\", verbose = FALSE, mc.cores = length(patients)) # names(genotyping_mt_all) <- patients # We already loaded the data. genotyping_mt_all <- parallel::mclapply(genotyping_mt_all, Filtering, min_variants_per_cell = 1, min_cells_per_variant = 2, fraction_threshold = 0.05, cells_include = erythroid_cells, verbose = FALSE, mc.cores = length(patients))"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"selecting-variants-of-interest-for-all-samples","dir":"Articles","previous_headings":"","what":"Selecting variants of interest for all samples","title":"Analysis of MPN Data","text":"select variants interest samples.","code":"# Selecting the mtVOIS. mt_vois_all <- parallel::mclapply(genotyping_mt_all, VariantSelection_Quantile, min_coverage = 1, verbose = FALSE, mc.cores = length(patients))  # Determining the clonal lineages. This takes very long. We use parallel computing to process all samples simultaneously. genotyping_mt_all <- parallel::mclapply(1:length(mt_vois_all), function(x){   sample_use <- names(mt_vois_all)[x]   clones <- ClonalDefinition(se = genotyping_mt_all[[sample_use]], mt_vois_all[sample_use], verbose = FALSE)   return(clones) }, mc.cores = length(mt_vois_all)) names(genotyping_mt_all) <- patients save_object(genotyping_mt_all, \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/Paper_Figures/ZenodoFiles/genotyping_mt_all.rds.lz4\", \"lz4\")"},{"path":"https://costalab.github.io/sigurd/articles/MPN_SIGURD.html","id":"calculating-the-diverstiy-for-all-samples","dir":"Articles","previous_headings":"","what":"Calculating the diverstiy for all samples","title":"Analysis of MPN Data","text":"","code":"# We load the previous results. genotyping_mt_all <- load_object(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/Paper_Figures/ZenodoFiles/genotyping_mt_all.rds.lz4\") clonal_diversity_all <- unlist(lapply(genotyping_mt_all, ClonalDiversity, grouping = \"Clones\", diversity_measure = \"EffectiveSpecies\", verbose = FALSE)) clonal_diversity_all <- data.frame(Sample = names(genotyping_mt_all), EffectiveSpecies = clonal_diversity_all) knitr::kable(clonal_diversity_all, format=\"html\")"},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"cell-mixture-analysis-using-sigurd","dir":"Articles","previous_headings":"","what":"Cell Mixture Analysis using SIGURD","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"data set, chronic myelogenous leukemia cells (K562) brain tumor cells (BT142) mixed sequenced using Seq-Well S3. cells can separated using expression marker genes. original script identifies 6 variants can distinguish two cell types. reproduction, show analysis can faithfully reproduced using streamlined set functions. greatly simplifies analysis. Using set dedicated functions, analysis can now also easily adopted new data sets.","code":""},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"loading-necessary-packages-","dir":"Articles","previous_headings":"","what":"Loading necessary packages.","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"load data MAESTER.","code":"print(\"Libraries for SIGURD.\") ## [1] \"Libraries for SIGURD.\" suppressPackageStartupMessages(library(sigurd)) suppressPackageStartupMessages(library(SummarizedExperiment)) suppressPackageStartupMessages(library(ggplot2))"},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"we-load-the-seurat-object-for-the-scrna-seq-data-","dir":"Articles","previous_headings":"","what":"We load the Seurat object for the scRNA-seq data.","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"","code":"seu <- readRDS(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/SW_CellLineMix_Seurat_Keep_Renamed.rds\")"},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"loading-the-data-using-sigurd-","dir":"Articles","previous_headings":"","what":"Loading the data using SIGURD.","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"SIGURD loads data automatically reformats data. code uses dedicated functions load process data, streamlines analysis quite substantially.","code":"# The design matrix contains information for the genotyping data. genotyping <- LoadingMAEGATK_typewise(patient = \"SW\", samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/MAESTER_Reproduction.csv\", min_cells = 0, type_use = \"Amplicon_MT\", verbose = FALSE)  # Removing cells that are not in the Seurat object. genotyping <- Filtering(genotyping, cells_include = colnames(seu)) ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We remove all the variants that are always NoCall.\" # Adding meta data do the SIGURD object. colData(genotyping)$CellType <- seu$CellType"},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"selecting-the-variants-of-interest","dir":"Articles","previous_headings":"","what":"Selecting the Variants of Interest","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"Now, select variants interest.","code":"# Selecting informative variants.  voi.ch.sigurd <- VariantSelection_Quantile(genotyping, min_coverage = 20, min_quality = 30, quantiles = c(0.1, 0.9), thresholds = c(0.1, 0.9), verbose = FALSE) print(voi.ch.sigurd) ## [1] \"chrM_709_G_A\"  \"chrM_1888_G_A\" \"chrM_1420_T_C\" \"chrM_2141_T_C\" ## [5] \"chrM_9117_T_C\" \"chrM_7990_C_T\""},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"visualisation-using-sigurd","dir":"Articles","previous_headings":"","what":"Visualisation using SIGURD","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"","code":"# Determining if a cell is supporting one of the two cell types. cell_support <- CallSupport(SE = genotyping, VOI_group1 = voi.ch.sigurd[voi.ch.sigurd != \"chrM_7990_C_T\"], VOI_group2 = \"chrM_7990_C_T\", group1_name = \"K562\", group2_name = \"BT142\", min_mutated_reads = 3, min_reads = 30, group_factor = 10, verbose = FALSE, return_nonsupport = TRUE) colData(genotyping)$CellType_MT <- cell_support$Support cell_support <- subset(cell_support, Support %in% c(\"K562\", \"BT142\")) # Selecting only cells with sufficient support for a set of variants.  # Plotting the results on a heatmap. HeatmapVoi(SE = genotyping[,cell_support$Cell], voi = voi.ch.sigurd, annotation_trait = \"CellType\", minimum_coverage = 3, remove_empty_cells = FALSE)"},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"selecting-variants-with-comparatively-high-vaf-between-groups","dir":"Articles","previous_headings":"","what":"Selecting variants with comparatively high VAF between groups","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"now select variants higher VAF K562 cells BT142 cells.","code":"voi.ch.lineages <- sigurd::VariantSelection_Group(SE = genotyping, min_coverage = 20, quantiles = c(0.01, 0.99), thresholds = c(0.01, 0.02), min_quality = 30,                                                   group_of_interest = \"CellType_MT\", group1 = \"K562\", group2 = \"BT142\", group_factor = 5, remove_nocall = FALSE, verbose = FALSE) voi.ch.lineages <- gsub(\"chrM_9117_T_C\", \"chrM_2141_T_C\", voi.ch.lineages) # Replace chrM_9117_T_C, which comes up because it has no coverage in some cells, with another homoplasmic variant (chrM_2141_T_C), that has better coverage) voi.ch.lineages <- voi.ch.lineages[!voi.ch.lineages %in% c(\"chrM_5378_A_G\", \"chrM_6384_G_A\")] # These variants are not detected in the bulk data and were removed by hand. print(voi.ch.lineages) ##  [1] \"chrM_1197_G_A\" \"chrM_1227_G_A\" \"chrM_1327_G_A\" \"chrM_1982_G_A\" ##  [5] \"chrM_2008_G_A\" \"chrM_2147_G_A\" \"chrM_2170_G_A\" \"chrM_2478_G_A\" ##  [9] \"chrM_2571_G_A\" \"chrM_2573_G_A\" \"chrM_2810_G_A\" \"chrM_2943_G_A\" ## [13] \"chrM_5274_G_A\" \"chrM_8155_G_A\" \"chrM_8213_G_A\" \"chrM_8278_C_A\" ## [17] \"chrM_9778_G_A\" \"chrM_2141_T_C\" \"chrM_1310_C_T\" \"chrM_1352_C_T\" ## [21] \"chrM_1533_C_T\" \"chrM_9757_C_T\""},{"path":"https://costalab.github.io/sigurd/articles/SW_CellMixture_SIGURD.html","id":"visualisation-using-sigurd-1","dir":"Articles","previous_headings":"","what":"Visualisation using SIGURD","title":"Cell Mixture Analysis using Seq-Well Sequencing","text":"","code":"# Plotting the results on a heatmap. cell_support <- subset(cell_support, Support == \"K562\") genotyping <- Filtering(genotyping, cells_include = cell_support$Cell, verbose = FALSE) HeatmapVoi(SE = genotyping, voi = voi.ch.lineages, minimum_coverage = 3, sort_cells = TRUE, cluster_variants = TRUE)"},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"cell-mixture-experiment-using-10x-genomics-sequencing","dir":"Articles","previous_headings":"","what":"Cell Mixture Experiment using 10X Genomics Sequencing","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":", reproduce analysis cell mixture experiment.","code":""},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"loading-necessary-packages-","dir":"Articles","previous_headings":"","what":"Loading necessary packages.","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":"load data MAESTER.","code":"print(\"Libraries for SIGURD.\") ## [1] \"Libraries for SIGURD.\" suppressPackageStartupMessages(library(sigurd)) suppressPackageStartupMessages(library(SummarizedExperiment)) suppressPackageStartupMessages(library(ggplot2))"},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"we-load-the-seurat-object-for-the-scrna-seq-data-","dir":"Articles","previous_headings":"","what":"We load the Seurat object for the scRNA-seq data.","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":"","code":"seu <- readRDS(\"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/TenX_CellLineMix_Seurat_Keep_Renamed.rds\")"},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"loading-the-data-using-sigurd-","dir":"Articles","previous_headings":"","what":"Loading the data using SIGURD.","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":"","code":"# The design matrix contains information for the genotyping data. genotyping <- LoadingMAEGATK_typewise(patient = \"TenX\", samples_file = \"/data/MPN/exp/scRNA/MPN_mutations/SIGURD_paper/sigurd/data/MAESTER_Reproduction.csv\", min_cells = 0, type_use = \"Amplicon_MT\", verbose = FALSE)  # Removing cells that are not in the Seurat object. genotyping <- Filtering(genotyping, cells_include = colnames(seu)) ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We remove all the variants that are always NoCall.\" # Adding meta data do the SIGURD object. colData(genotyping)$CellType <- seu$CellType"},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"selecting-the-variants-of-interest","dir":"Articles","previous_headings":"","what":"Selecting the Variants of Interest","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":"","code":"# Selecting informative variants.  voi.ch.sigurd <- VariantSelection_Quantile(genotyping, min_coverage = 20, min_quality = 30, quantiles = c(0.1, 0.9), thresholds = c(0.1, 0.9), verbose = FALSE) print(voi.ch.sigurd) ##  [1] \"chrM_709_G_A\"   \"chrM_1888_G_A\"  \"chrM_6249_G_A\"  \"chrM_8697_G_A\"  ##  [5] \"chrM_11719_G_A\" \"chrM_15452_C_A\" \"chrM_1420_T_C\"  \"chrM_2141_T_C\"  ##  [9] \"chrM_4216_T_C\"  \"chrM_6524_T_C\"  \"chrM_9117_T_C\"  \"chrM_11251_A_G\" ## [13] \"chrM_11764_A_G\" \"chrM_11812_A_G\" \"chrM_15607_A_G\" \"chrM_7990_C_T\"  ## [17] \"chrM_12741_C_T\""},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"visualisation-using-sigurd","dir":"Articles","previous_headings":"","what":"Visualisation using SIGURD","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":"","code":"# Determining if a cell is supporting one of the two cell types. cell_support <- CallSupport(SE = genotyping, VOI_group1 = voi.ch.sigurd[voi.ch.sigurd != \"chrM_7990_C_T\"], VOI_group2 = \"chrM_7990_C_T\", group1_name = \"K562\", group2_name = \"BT142\", min_mutated_reads = 3, min_reads = 30, group_factor = c(10,2), verbose = FALSE) genotyping <- Filtering(genotyping, cells_include = cell_support$Cell) ## [1] \"We remove all cells not in the allow list.\" ## [1] \"We remove all the variants that are always NoCall.\" colData(genotyping)$CellType_MT <- cell_support$Support cell_support <- subset(cell_support, Support %in% c(\"K562\", \"BT142\")) # Selecting only cells with sufficient support for a set of variants.  # Plotting the results on a heatmap. HeatmapVoi(SE = genotyping, voi = voi.ch.sigurd, annotation_trait = \"CellType\", minimum_coverage = 3)"},{"path":"https://costalab.github.io/sigurd/articles/TenX_CellMixture_SIGURD.html","id":"selecting-variants-with-comparatively-high-vaf-between-groups","dir":"Articles","previous_headings":"","what":"Selecting variants with comparatively high VAF between groups","title":"Cell Mixture Experiment using 10X Genomics Sequencing","text":"now select variants higher VAF K562 cells BT142 cells.","code":"voi.ch.lineages <- sigurd::VariantSelection_Group(SE = genotyping, min_coverage = 100, quantiles = c(0.01, 0.99), thresholds = c(0.01, 0.02), min_quality = 30,                                                   group_of_interest = \"CellType_MT\", group1 = \"K562\", group2 = \"BT142\", group_factor = 5, remove_nocall = FALSE, verbose = FALSE) voi.ch.lineages <- voi.ch.lineages[!voi.ch.lineages %in% c(\"chrM_8251_G_A\", \"chrM_7693_C_T\")] # These variants are not detected in the bulk data and were removed by hand. voi.ch.lineages <- c(voi.ch.lineages, \"chrM_2141_T_C\") # Adding a homoplasmic variant as positive control. print(voi.ch.lineages) ##  [1] \"chrM_1916_G_A\"  \"chrM_2008_G_A\"  \"chrM_2147_G_A\"  \"chrM_2551_G_A\"  ##  [5] \"chrM_2571_G_A\"  \"chrM_2573_G_A\"  \"chrM_7269_G_A\"  \"chrM_7337_G_A\"  ##  [9] \"chrM_7362_G_A\"  \"chrM_7706_G_A\"  \"chrM_8155_G_A\"  \"chrM_9247_G_A\"  ## [13] \"chrM_9778_G_A\"  \"chrM_10223_C_A\" \"chrM_11531_G_A\" \"chrM_11914_G_A\" ## [17] \"chrM_15374_G_A\" \"chrM_8211_T_C\"  \"chrM_9613_T_C\"  \"chrM_1733_C_T\"  ## [21] \"chrM_2357_C_T\"  \"chrM_2574_G_T\"  \"chrM_7825_C_T\"  \"chrM_9757_C_T\"  ## [25] \"chrM_9822_C_T\"  \"chrM_11965_C_T\" \"chrM_12102_C_T\" \"chrM_2141_T_C\" # Plotting the results on a heatmap. cell_support <- subset(cell_support, Support == \"K562\") # Only plotting K562 cells. genotyping <- Filtering(genotyping, cells_include = cell_support$Cell, verbose = FALSE) HeatmapVoi(SE = genotyping, voi = voi.ch.lineages, minimum_coverage = 3, sort_cells = TRUE, cluster_variants = TRUE)"},{"path":"https://costalab.github.io/sigurd/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin Grasshoff. Author, maintainer. Ivan Costa. Author.","code":""},{"path":"https://costalab.github.io/sigurd/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Grasshoff M, Costa (2025). sigurd: Single cell Genotyping Using RNA Data. R package version 0.3.14, https://costalab.github.io/sigurd/.","code":"@Manual{,   title = {sigurd: Single cell Genotyping Using RNA Data},   author = {Martin Grasshoff and Ivan Costa},   year = {2025},   note = {R package version 0.3.14},   url = {https://costalab.github.io/sigurd/}, }"},{"path":"https://costalab.github.io/sigurd/index.html","id":"single-cell-genotyping-using-rna-data-sigurd","dir":"","previous_headings":"","what":"Single cell Genotyping Using RNA Data","title":"Single cell Genotyping Using RNA Data","text":"Martin Graßhoff1 Ivan G. Costa1 1Institute Computational Genomics, Faculty Medicine, RWTH Aachen University, Aachen, 52074 Germany Motivation: advent single RNA seq assays, became possible determine mutational status individual cell. Single cell RNA seq data nature sparse probability hitting specific variants interest therefore low. issue can overcome using modified amplicon assays, also possible impute mutational status using correlation detected mitochondrial somatic variants. Results: Sigurd R package analysis single cell data. determine overall variant burden per cell also number interesting mitochondrial variants using previously published approaches. employ imputation approach utilizes correlation mitochondrial variants somatic variants. Mitochondrial mutations significantly associated somatic mutations used stand-ins.","code":""},{"path":"https://costalab.github.io/sigurd/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Single cell Genotyping Using RNA Data","text":"can install sigurd using following code. vignette requires data currently published, provided reference.","code":"install.packages(\"devtools\") devtools::install_github(\"https://github.com/CostaLab/sigurd.git\", build_vignettes = FALSE) require(sigurd)"},{"path":"https://costalab.github.io/sigurd/index.html","id":"sigurd","dir":"","previous_headings":"","what":"SIGURD","title":"Single cell Genotyping Using RNA Data","text":"provided small example data set SIGURD. consists chromosome 9 MT one MPN sample.","code":"# This will be included for published data. # vignette('sigurd')"},{"path":"https://costalab.github.io/sigurd/index.html","id":"current-features-v0-3-14","dir":"","previous_headings":"","what":"Current Features v0.3.14","title":"Single cell Genotyping Using RNA Data","text":"Loading data VarTrix MAEGATK. Transforming data compatible joint analysis. Calculating variant burden per cell. Thresholding variants using approach described Miller et al. [2] Finding associated variants using correlation Fisher Test.","code":""},{"path":"https://costalab.github.io/sigurd/index.html","id":"sources","dir":"","previous_headings":"","what":"Sources","title":"Single cell Genotyping Using RNA Data","text":"package implements approaches following packages respositories: - https://github.com/petervangalen/MAESTER-2021 – Variant Thresholding functions loading MAEGATK data. - https://github.com/CostaLab/CimpleG – loading saving function.","code":""},{"path":"https://costalab.github.io/sigurd/index.html","id":"future","dir":"","previous_headings":"","what":"Future","title":"Single cell Genotyping Using RNA Data","text":"Memory optimization Loading CB sniffer results Providing data vignette","code":""},{"path":"https://costalab.github.io/sigurd/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Single cell Genotyping Using RNA Data","text":"[1] VarTrix. github [2] Miller, T.E., et al. Mitochondrial variant enrichment high-throughput single-cell RNA sequencing resolves clonal populations. Nat Biotechnol (2022). link. See also: MAEGATK Analysis, Data","code":""},{"path":"https://costalab.github.io/sigurd/reference/AllelFrequencyFoldChange.html","id":null,"dir":"Reference","previous_headings":"","what":"AllelFrequencyFoldChange — AllelFrequencyFoldChange","title":"AllelFrequencyFoldChange — AllelFrequencyFoldChange","text":"Check cell supported set variants.","code":""},{"path":"https://costalab.github.io/sigurd/reference/AllelFrequencyFoldChange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AllelFrequencyFoldChange — AllelFrequencyFoldChange","text":"","code":"AllelFrequencyFoldChange(   SE,   VOI = NULL,   group_of_interest,   group1 = \"group1\",   group2 = \"group2\",   maximum_foldchange = NULL,   minimum_foldchange = NULL,   minimum_coverage = NULL,   minimum_allele_freq = NULL,   maximum_allele_freq = NULL,   verbose = FALSE )"},{"path":"https://costalab.github.io/sigurd/reference/AllelFrequencyFoldChange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AllelFrequencyFoldChange — AllelFrequencyFoldChange","text":"SE SummarizedExperiment object. VOI variants variants analyzed. NULL used. group_of_interest column data divides cells. group1 first group. group2 second group. maximum_foldchange Maximum fold change. minimum_foldchange Minimum fold change. minimum_coverage Minimum coverage variant. minimum_allele_freq Minimum allele frequency groups. maximum_allele_freq Maximum allele frequency groups. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/AmpliconSupplementing.html","id":null,"dir":"Reference","previous_headings":"","what":"Supplementing scRNAseq values with Amplicon values — AmpliconSupplementing","title":"Supplementing scRNAseq values with Amplicon values — AmpliconSupplementing","text":"replace values scRNAseq experiment values amplicon experiment.","code":""},{"path":"https://costalab.github.io/sigurd/reference/AmpliconSupplementing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supplementing scRNAseq values with Amplicon values — AmpliconSupplementing","text":"","code":"AmpliconSupplementing(scRNAseq, amplicon, verbose = TRUE)"},{"path":"https://costalab.github.io/sigurd/reference/AmpliconSupplementing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supplementing scRNAseq values with Amplicon values — AmpliconSupplementing","text":"scRNAseq SummarizedExperiment object containing scRNAseq data. amplicon SummarizedExperiment object containing amplicon data. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateAlleleFrequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating the Minor Allele Frequency. — CalculateAlleleFrequency","title":"Calculating the Minor Allele Frequency. — CalculateAlleleFrequency","text":"calculate MAF reference reads matrix alternative reads matrix. function intended used mitochondrial genome somatic mutations.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateAlleleFrequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating the Minor Allele Frequency. — CalculateAlleleFrequency","text":"","code":"CalculateAlleleFrequency(reference_reads, alternative_reads, pseudo_count = 0)"},{"path":"https://costalab.github.io/sigurd/reference/CalculateAlleleFrequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating the Minor Allele Frequency. — CalculateAlleleFrequency","text":"reference_reads Reference reads matrix. alternative_reads List matrices alternative reads. pseudo_count = pseudo count want add reference_reads matrix. Default = 0","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateAltReads.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateAltReads — CalculateAltReads","title":"CalculateAltReads — CalculateAltReads","text":"calculate number reads covering variant using forward reverse reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateAltReads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateAltReads — CalculateAltReads","text":"","code":"CalculateAltReads(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateAltReads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateAltReads — CalculateAltReads","text":"SE SummarizedExperiment object. chromosome_prefix List matrices alternative reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateConsensus.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateConsensus — CalculateConsensus","title":"CalculateConsensus — CalculateConsensus","text":"calculate consensus information MAEGATK results. set cells alternative reads 2 (Alternative). set cells reference reads 1 (Reference). set cells mixture alternative reference reads 3 (). set cells reads 0 (NoCall). Please note. Cells can reads reference specific variant reads alternative. cell can still reads alternative alleles. cell still considered 0 (NoCall) variant. example: cell position 3: 0 reads, 53 T reads, 63 C reads, 148 T reads. variant chrM_3_T_A, cell 53 reference reads, also reads variants position. make sure confusion, cell set NoCall.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateConsensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateConsensus — CalculateConsensus","text":"","code":"CalculateConsensus(SE, chromosome_prefix = \"chrM\", verbose = FALSE)"},{"path":"https://costalab.github.io/sigurd/reference/CalculateConsensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateConsensus — CalculateConsensus","text":"SE SummarizedExperiment object. chromosome_prefix chromosome name used prefix. verbose function verbose? Default = FALSE","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateCorrelationPValue.html","id":null,"dir":"Reference","previous_headings":"","what":"Correlating the SNVs — CalculateCorrelationPValue","title":"Correlating the SNVs — CalculateCorrelationPValue","text":"perform correlation SNVs calculate P values.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateCorrelationPValue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Correlating the SNVs — CalculateCorrelationPValue","text":"","code":"CalculateCorrelationPValue(   variant_values,   other_mutation,   all_variants_list,   value_type = \"consensus\",   min_intersecting_cells = 5 )"},{"path":"https://costalab.github.io/sigurd/reference/CalculateCorrelationPValue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Correlating the SNVs — CalculateCorrelationPValue","text":"variant_values fraction values analyzing. vector. other_mutation variants . vector variant names. all_variants_list List fraction values variants want compare variant . value_type using consensus information? min_intersecting_cells Minimum number intersecting cells. Correlations less performed.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateCoverage.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateCoverage — CalculateCoverage","title":"CalculateCoverage — CalculateCoverage","text":"calculate coverage information per variant MAEGATK results.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateCoverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateCoverage — CalculateCoverage","text":"","code":"CalculateCoverage(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateCoverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateCoverage — CalculateCoverage","text":"SE SummarizedExperiment object. chromosome_prefix List matrices alternative reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateFisherTestPValue.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateFisherTestPValue — CalculateFisherTestPValue","title":"CalculateFisherTestPValue — CalculateFisherTestPValue","text":"perform Fisher Test SNVs calculate P values.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateFisherTestPValue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateFisherTestPValue — CalculateFisherTestPValue","text":"","code":"CalculateFisherTestPValue(   variant_values,   other_mutation,   all_variants_list,   min_intersecting_cells = 5 )"},{"path":"https://costalab.github.io/sigurd/reference/CalculateFisherTestPValue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateFisherTestPValue — CalculateFisherTestPValue","text":"variant_values fraction values analysing. vector. other_mutation variants . vector variant names. all_variants_list List fraction values variants want compare variant . min_intersecting_cells Minimum number intersecting cells. Correlations less performed.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateForwardReads.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateForwardReads — CalculateForwardReads","title":"CalculateForwardReads — CalculateForwardReads","text":"calculate number forward reads covering variant.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateForwardReads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateForwardReads — CalculateForwardReads","text":"","code":"CalculateForwardReads(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateForwardReads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateForwardReads — CalculateForwardReads","text":"SE SummarizedExperiment object. chromosome_prefix List matrices alternative reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateQuality.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateQuality — CalculateQuality","title":"CalculateQuality — CalculateQuality","text":"calculate quality per variant.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateQuality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateQuality — CalculateQuality","text":"","code":"CalculateQuality(SE, variants, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateQuality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateQuality — CalculateQuality","text":"SE SummarizedExperiment object. variants variants want get quality . chromosome_prefix List matrices alternative reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateRefReads.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateRefReads — CalculateRefReads","title":"CalculateRefReads — CalculateRefReads","text":"calculate number reference reads covering variant using forward reverse reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateRefReads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateRefReads — CalculateRefReads","text":"","code":"CalculateRefReads(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateRefReads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateRefReads — CalculateRefReads","text":"SE SummarizedExperiment object. chromosome_prefix List matrices reference reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateReverseReads.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateReverseReads — CalculateReverseReads","title":"CalculateReverseReads — CalculateReverseReads","text":"calculate number reverse reads covering variant.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateReverseReads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateReverseReads — CalculateReverseReads","text":"","code":"CalculateReverseReads(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateReverseReads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateReverseReads — CalculateReverseReads","text":"SE SummarizedExperiment object. chromosome_prefix List matrices alternative reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateStrandCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"CalculateStrandCorrelation — CalculateStrandCorrelation","title":"CalculateStrandCorrelation — CalculateStrandCorrelation","text":"calculate correlation amount forward reverse reads per variant.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CalculateStrandCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CalculateStrandCorrelation — CalculateStrandCorrelation","text":"","code":"CalculateStrandCorrelation(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/CalculateStrandCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CalculateStrandCorrelation — CalculateStrandCorrelation","text":"SE SummarizedExperiment object. chromosome_prefix List matrices alternative reads.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CallSupport.html","id":null,"dir":"Reference","previous_headings":"","what":"CallSupport — CallSupport","title":"CallSupport — CallSupport","text":"Check cell supported set variants.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CallSupport.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CallSupport — CallSupport","text":"","code":"CallSupport(   SE,   VOI_group1,   VOI_group2,   group1_name = \"group1\",   group2_name = \"group2\",   min_mutated_reads = 3,   min_reads = 30,   group_factor = NULL,   verbose = TRUE,   return_nonsupport = FALSE )"},{"path":"https://costalab.github.io/sigurd/reference/CallSupport.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CallSupport — CallSupport","text":"SE SummarizedExperiment object. VOI_group1 variants supporting first group. VOI_group2 variants supporting second group. group1_name name used first group. group2_name name used second group. min_mutated_reads minimum number mutated reads cell supporting group. min_reads Minimum number reads per cell classification. group_factor much higher mean allele frequency group 1 compared group 2 vice versa? Can vector length 2. verbose function verbose? Default = TRUE return_nonsupport nonsupporting cells return ? Default FALSE. group_of_interest column data divides cells.","code":""},{"path":"https://costalab.github.io/sigurd/reference/ClonalDefinition.html","id":null,"dir":"Reference","previous_headings":"","what":"Defining clones. — ClonalDefinition","title":"Defining clones. — ClonalDefinition","text":"function defines clones using combination variants supplied. set variants can paired identity, like sample cell type. clones determined respect group. information provided, clones determined cells present.","code":""},{"path":"https://costalab.github.io/sigurd/reference/ClonalDefinition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defining clones. — ClonalDefinition","text":"","code":"ClonalDefinition(   se,   variants_ls,   grouping = NULL,   identities = NULL,   explicit = FALSE,   explicit_not = NULL,   explicit_min_vaf = 0.01,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/ClonalDefinition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defining clones. — ClonalDefinition","text":"se SummarizedExperiment object. variants_ls List variants clonal definition grouping meta data    column used split cells groups. Default = NULL identities Vector groups, like samples. explicit want specify variants forming clone? variant_ls needs list variants define clone. One variant per group. explicit_not want specify set variants cell may ? One set per group. explicit_min_vaf Minimum VAF cell considered positive. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/ClonalDefinition_Singular.html","id":null,"dir":"Reference","previous_headings":"","what":"Defining a single clone using multiple variants. — ClonalDefinition_Singular","title":"Defining a single clone using multiple variants. — ClonalDefinition_Singular","text":"function defines single clone using set variants. cell considered part clone, provided variants. maximum number missing variants can set.","code":""},{"path":"https://costalab.github.io/sigurd/reference/ClonalDefinition_Singular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defining a single clone using multiple variants. — ClonalDefinition_Singular","text":"","code":"ClonalDefinition_Singular(   se,   variants,   dropout = FALSE,   variants_essential = NULL,   variants_excluding = NULL,   min_vaf = 0.01,   clone_name = \"SingularClone\",   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/ClonalDefinition_Singular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defining a single clone using multiple variants. — ClonalDefinition_Singular","text":"se SummarizedExperiment object. variants Set variants clonal definition. dropout number missing variants allowed. variants_essential variants considered essential? dropped dropout NULL. values can either variants names character indices variants. list length variants. variants_excluding variants allowed clone? Variants names.  list length variants. min_vaf Minimum VAF cell considered positive. clone_name name clone? Default: SingularClone verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/ClonalDiversity.html","id":null,"dir":"Reference","previous_headings":"","what":"Determining the clonal diversity. — ClonalDiversity","title":"Determining the clonal diversity. — ClonalDiversity","text":"function determines clonal diversity. clones defined using function ClonalDefinition. required use clones, column column data object can used.","code":""},{"path":"https://costalab.github.io/sigurd/reference/ClonalDiversity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determining the clonal diversity. — ClonalDiversity","text":"","code":"ClonalDiversity(   se,   grouping = \"Clones\",   cells = NULL,   diversity_measure = \"EffectiveSpecies\",   base = exp(1),   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/ClonalDiversity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determining the clonal diversity. — ClonalDiversity","text":"se SummarizedExperiment object. grouping meta data    column used. cells cells used? NULL uses cells. diversity_measure diversity measure calculated? Can EffectiveSpecies, shannon, simpson, invsimpson base base diversity verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/CombineSEobjects.html","id":null,"dir":"Reference","previous_headings":"","what":"CombineSEobjects — CombineSEobjects","title":"CombineSEobjects — CombineSEobjects","text":"combine two SummarizedExperiment objects. originally intended add mitochondrial genotyping information somatic genotyping information. function can combine two objects requried two different genotyping results.","code":""},{"path":"https://costalab.github.io/sigurd/reference/CombineSEobjects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CombineSEobjects — CombineSEobjects","text":"","code":"CombineSEobjects(se_1, se_2, suffixes = c(\"_1\", \"_2\"), patient_check = FALSE)"},{"path":"https://costalab.github.io/sigurd/reference/CombineSEobjects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CombineSEobjects — CombineSEobjects","text":"se_1 SummarizedExperiment object 1. se_2 SummarizedExperiment object 2. suffixes suffixes want add meta data.frame. patient_check patient column data check, ?","code":""},{"path":"https://costalab.github.io/sigurd/reference/Enrichment_FisherTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Enrichment_FisherTest — Enrichment_FisherTest","title":"Enrichment_FisherTest — Enrichment_FisherTest","text":"function performs Fisher test. specified variant ","code":""},{"path":"https://costalab.github.io/sigurd/reference/Enrichment_FisherTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enrichment_FisherTest — Enrichment_FisherTest","text":"","code":"Enrichment_FisherTest(   se = NULL,   variant = NULL,   use_nocall = FALSE,   both_as_alt = TRUE,   trait = NULL,   trait_levels = NULL )"},{"path":"https://costalab.github.io/sigurd/reference/Enrichment_FisherTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enrichment_FisherTest — Enrichment_FisherTest","text":"se SummarizedExperiment object. variant variant analysed. values variant retrieved consensus assay. use_nocall NoCall values used? non genotyped cells separate group addition Alt Ref. FALSE, NoCalls removed. Default = FALSE both_as_alt consensus value heterozyguous (3 ) treated homozyguous (Alt)? Default = TRUE trait trait variant associated . can column colData object. trait_levels trait levels used comparison? example, Sample 1-3 present 1 2 used comparison use trait_levels = c(\"Sample_1\", \"Sample_2\"). NULL uses levels. Default = NULL","code":""},{"path":"https://costalab.github.io/sigurd/reference/Filtering.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtering the loaded genotyping data. — Filtering","title":"Filtering the loaded genotyping data. — Filtering","text":"filter SummarizedExperiment object exclude variants cells.","code":""},{"path":"https://costalab.github.io/sigurd/reference/Filtering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtering the loaded genotyping data. — Filtering","text":"","code":"Filtering(   SE,   cells_include = NULL,   cells_exclude = NULL,   fraction_threshold = NULL,   keep_refs = TRUE,   alts_threshold = NULL,   min_cells_per_variant = NULL,   min_variants_per_cell = NULL,   reject_value = \"NoCall\",   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/Filtering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtering the loaded genotyping data. — Filtering","text":"SE SummarizedExperiment object. cells_include vector cell barcodes. cells retained. cells_exclude vector cell barcodes. cells removed output. fraction_threshold Variants VAF threshold set 0. Numeric. Default = NULL. keep_refs cell fraction_threshold, number reference reads kept? FALSE, reference reads removed. Default = TRUE alts_threshold Variants number alt reads less threshold set 0. Numeric. Default = NULL. min_cells_per_variant many cells variant present included? Numeric. Default = 2. min_variants_per_cell many variants covered cell included? Default = 1. reject_value cells fall threshold (fraction_threshold alts_threshold) treated Reference NoCall? Default = NoCall. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/Filtering.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filtering the loaded genotyping data. — Filtering","text":"one sample time. want remove: cells allow list, cells exclusion list, cells least one variant >1 (Reference), variants alternative transcripts, variants always NoCall, set variants VAF threshold NoCall Reference.","code":""},{"path":"https://costalab.github.io/sigurd/reference/Filtering.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtering the loaded genotyping data. — Filtering","text":"","code":"if (FALSE) {   # Removing all variants that are not detected in at least 2 cells.   # Before we remove the variants, we set fraction value of variants below 0.05 to 0.   se_geno <- Filtering(se_geno, min_cells_per_variant = 2, fraction_threshold = 0.05) }"},{"path":"https://costalab.github.io/sigurd/reference/Filtering_VAF_Threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtering_VAF_Threshold — Filtering_VAF_Threshold","title":"Filtering_VAF_Threshold — Filtering_VAF_Threshold","text":"determine number mutated cells given variant using vector VAF thresholds.","code":""},{"path":"https://costalab.github.io/sigurd/reference/Filtering_VAF_Threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtering_VAF_Threshold — Filtering_VAF_Threshold","text":"","code":"Filtering_VAF_Threshold(SE, variant = NULL, thresholds = NULL, verbose = TRUE)"},{"path":"https://costalab.github.io/sigurd/reference/Filtering_VAF_Threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtering_VAF_Threshold — Filtering_VAF_Threshold","text":"SE SummarizedExperiment object. variant variant evaluated? 1 variant time. thresholds thresholds evaluated. Default 0.01 0.99 steps 0.01. verbose function verbose?","code":""},{"path":"https://costalab.github.io/sigurd/reference/GetCellInfoPerVariant.html","id":null,"dir":"Reference","previous_headings":"","what":"We get the variant information per cell. — GetCellInfoPerVariant","title":"We get the variant information per cell. — GetCellInfoPerVariant","text":"get variant information per cell.","code":""},{"path":"https://costalab.github.io/sigurd/reference/GetCellInfoPerVariant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"We get the variant information per cell. — GetCellInfoPerVariant","text":"","code":"GetCellInfoPerVariant(se, voi_ch, verbose = FALSE)"},{"path":"https://costalab.github.io/sigurd/reference/GetCellInfoPerVariant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"We get the variant information per cell. — GetCellInfoPerVariant","text":"se SummarizedExperiment object. voi_ch Variants interest. verbose function verbose? Default = FALSE","code":""},{"path":"https://costalab.github.io/sigurd/reference/GetVariantInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"GetVariantInfo — GetVariantInfo","title":"GetVariantInfo — GetVariantInfo","text":"get genotyping information set variants. function returns matrix values specified assay.","code":""},{"path":"https://costalab.github.io/sigurd/reference/GetVariantInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetVariantInfo — GetVariantInfo","text":"","code":"GetVariantInfo(SE, information = \"consensus\", variants = NULL, cells = NULL)"},{"path":"https://costalab.github.io/sigurd/reference/GetVariantInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetVariantInfo — GetVariantInfo","text":"SE SummarizedExperiment object. information assay desired information. Default: consensus variants vector variants. cells vector cell IDs. default cells returned. Default: NULL","code":""},{"path":"https://costalab.github.io/sigurd/reference/HeatmapVoi.html","id":null,"dir":"Reference","previous_headings":"","what":"HeatmapVoi — HeatmapVoi","title":"HeatmapVoi — HeatmapVoi","text":"plot heatmap set Variants Interest using Variant Allele Frequency values SummarizedExperiment object.","code":""},{"path":"https://costalab.github.io/sigurd/reference/HeatmapVoi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HeatmapVoi — HeatmapVoi","text":"","code":"HeatmapVoi(   SE,   voi,   annotation_trait = NULL,   column_title = NULL,   minimum_coverage = 0,   sort_cells = FALSE,   remove_empty_cells = FALSE,   minimum_allele_freq = 0,   cluster_variants = FALSE,   cluster_variants_distance = \"euclidean\",   cluster_variants_method = \"complete\" )"},{"path":"https://costalab.github.io/sigurd/reference/HeatmapVoi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HeatmapVoi — HeatmapVoi","text":"SE SummarizedExperiment object. voi Variants Interest. annotation_trait Cell Annotation bottom heat map. column_title title heat map. Default = NULL minimum_coverage minimum coverage per cell plotted. sort_cells cells sorted ordering cells according largest clones? FALSE uses default complete clustering euclidean distance. remove_empty_cells cells fraction 0 variants removed? Default = FALSE minimum_allele_freq Minimum allele frequency include cell. cluster_variants variants clustered? Default FALSE. cluster_variants_distance distance clustering variants. Default euclidean. cluster_variants_method distance variant clustering. Default complete","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingMAEGATK_typewise.html","id":null,"dir":"Reference","previous_headings":"","what":"LoadingMAEGATK_typewise — LoadingMAEGATK_typewise","title":"LoadingMAEGATK_typewise — LoadingMAEGATK_typewise","text":"load MAEGATK output transform compatible VarTrix output. input file specifically formated csv file necessary information run analysis. Note source column input file needs mgaetk mgatk function. case insensitive. want load single sample without use input file, set following variables. samples_path barcodes_path patient samples_file = NULL","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingMAEGATK_typewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LoadingMAEGATK_typewise — LoadingMAEGATK_typewise","text":"","code":"LoadingMAEGATK_typewise(   samples_file,   patient,   samples_path = NULL,   patient_column = \"patient\",   type_use = \"scRNAseq_MT\",   chromosome_prefix = \"chrM\",   min_cells = 2,   cells_include = NULL,   cells_exclude = NULL,   barcodes_path = NULL,   cellbarcode_length = 18,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/LoadingMAEGATK_typewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LoadingMAEGATK_typewise — LoadingMAEGATK_typewise","text":"samples_file Path csv file samples loaded. patient patient want load. samples_path Path input folder. patient_column column contains patient information. Use merge, samples merged. type_use type input. rows specified type loaded. chromosome_prefix prefix want use. Default: \"chrM\" min_cells minimum number cells coverage variant. Variants coverage less amount cells removed. Default = 2 cells_include vector cell barcodes. cells retained. cells_exclude vector cell barcodes. cells removed output. barcodes_path Path barcodes file tsv. Default = NULL cellbarcode_length length cell barcode. length actual barcode plus two suffix (-1). Default = 18 verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingMGATK_typewise.html","id":null,"dir":"Reference","previous_headings":"","what":"LoadingMGATK_typewise — LoadingMGATK_typewise","title":"LoadingMGATK_typewise — LoadingMGATK_typewise","text":"load MGATK output transform compatible VarTrix output. input file specifically formatted csv file necessary information run analysis. Note source column input file needs mgaetk mgatk function. case insensitive. want load single sample without use input file, set following variables. samples_path barcodes_path patient samples_file = NULL","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingMGATK_typewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LoadingMGATK_typewise — LoadingMGATK_typewise","text":"","code":"LoadingMGATK_typewise(   samples_file,   patient,   samples_path = NULL,   patient_column = \"patient\",   type_use = \"scRNAseq_MT\",   chromosome_prefix = \"chrM\",   min_cells = 2,   cells_include = NULL,   cells_exclude = NULL,   barcodes_path = NULL,   cellbarcode_length = 18,   ignore_quality = TRUE,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/LoadingMGATK_typewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LoadingMGATK_typewise — LoadingMGATK_typewise","text":"samples_file Path csv file samples loaded. patient patient want load. samples_path Path input folder. patient_column column contains patient information. Use merge, samples merged. type_use type input. rows specified type loaded. chromosome_prefix prefix want use. Default: \"chrM\" min_cells minimum number cells coverage variant. Variants coverage less amount cells removed. Default = 2 cells_include vector cell barcodes. cells retained. cells_exclude vector cell barcodes. cells removed output. barcodes_path Path barcodes file tsv. Default = NULL cellbarcode_length length cell barcode. length actual barcode plus two suffix (-1). Default = 18 ignore_quality quality assay ignore? can useful quality reported mgatk. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingRawMatrix_typewise.html","id":null,"dir":"Reference","previous_headings":"","what":"LoadingRawMatrix_typewise — LoadingRawMatrix_typewise","title":"LoadingRawMatrix_typewise — LoadingRawMatrix_typewise","text":"function load dense matrix genotyping information reformat . matrix column cell barcodes, one reference reads one alternative reads. type design matrix used variant name.","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingRawMatrix_typewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LoadingRawMatrix_typewise — LoadingRawMatrix_typewise","text":"","code":"LoadingRawMatrix_typewise(   samples_file,   patient,   patient_column = \"patient\",   variant_use = NULL,   cells_include = NULL,   cells_exclude = NULL,   matrix_column_separator = \",\",   matrix_header = TRUE,   cellbarcode_index = 1,   ref_index = 2,   alt_index = 3,   cellbarcode_length = 18,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/LoadingRawMatrix_typewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LoadingRawMatrix_typewise — LoadingRawMatrix_typewise","text":"samples_file Path csv file samples loaded. patient patient want load. patient_column column contains patient information. variant_use variant respective matrices. cells_include vector cell barcodes. cells retained. cells_exclude vector cell barcodes. cells removed output. cellbarcode_length length cell barcode. length actual barcode plus two suffix (-1). Default = 18 verbose function verbose? Default = TRUE samples_path Path input folder. Must include barcodes file.","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingVCF_typewise.html","id":null,"dir":"Reference","previous_headings":"","what":"LoadingVCF_typewise — LoadingVCF_typewise","title":"LoadingVCF_typewise — LoadingVCF_typewise","text":"load cellwise pileup result VCF file. want load single sample without use input file, set following variables. samples_path patient samples_file = NULL Note source column input file needs vcf function. case insensitive. happened reads N allele aligned. can cause problems since variants typically variants lists. can remove variants setting remove_N_alternative TRUE (default). Set option FALSE, really want retain variants.","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingVCF_typewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LoadingVCF_typewise — LoadingVCF_typewise","text":"","code":"LoadingVCF_typewise(   samples_file,   samples_path = NULL,   vcf_path,   patient,   patient_column = \"patient\",   type_use = \"scRNAseq_Somatic\",   min_reads = NULL,   min_cells = 2,   cells_include = NULL,   cells_exclude = NULL,   remove_N_alternative = TRUE,   cellbarcode_length = 18,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/LoadingVCF_typewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LoadingVCF_typewise — LoadingVCF_typewise","text":"samples_file Path csv file samples loaded. samples_path Path input folder. vcf_path Path VCF file variants. patient patient want load. patient_column column contains patient information. Use merge, samples merged. type_use type input. rows specified type loaded. min_reads minimum number reads want. Otherwise treat NoCall. Default = NULL. min_cells minimum number cells variant. Otherwise, remove variant. Default = 2. cells_include vector cell barcodes. cells retained. cells_exclude vector cell barcodes. cells removed output. remove_N_alternative Remove variants N alternative, see Description. Default = TRUE cellbarcode_length length cell barcode. length actual barcode plus two suffix (-1). Default = 18 verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingVarTrix_typewise.html","id":null,"dir":"Reference","previous_headings":"","what":"LoadingVarTrix_typewise — LoadingVarTrix_typewise","title":"LoadingVarTrix_typewise — LoadingVarTrix_typewise","text":"load different types results (scRNAseq/amplicon MT/amplicon), might need extreme amounts memory. solve issue, load type separately. following function (AmpliconSupplementing), can add amplicon information scRNAseq information. input file specifically formatted csv file necessary information run analysis. Note source column input file needs vartrix function. hard coded case insensitive.","code":""},{"path":"https://costalab.github.io/sigurd/reference/LoadingVarTrix_typewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LoadingVarTrix_typewise — LoadingVarTrix_typewise","text":"","code":"LoadingVarTrix_typewise(   samples_file,   samples_path = NULL,   barcodes_path = NULL,   snp_path = NULL,   vcf_path,   patient,   patient_column = \"patient\",   type_use = \"scRNAseq_Somatic\",   min_reads = NULL,   min_cells = 2,   cells_include = NULL,   cells_exclude = NULL,   cellbarcode_length = 18,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/LoadingVarTrix_typewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LoadingVarTrix_typewise — LoadingVarTrix_typewise","text":"samples_file Path csv file samples loaded. samples_path Path input folder. Must include barcodes file. barcodes_path path cell barcodes tsv. Default = NULL snp_path Path SNP file used VarTrix (SNV.loci.txt). vcf_path Path VCF file variants. patient patient want load. patient_column column contains patient information. Use merge, samples merged. type_use type input. rows specified type loaded. min_reads minimum number reads want. Otherwise treat NoCall. Default = NULL. min_cells minimum number cells variant. Otherwise, remove variant. Default = 2. cells_include vector cell barcodes. cells retained. cells_exclude vector cell barcodes. cells removed output. cellbarcode_length length cell barcode. length actual barcode plus two suffix (-1). Default = 18 verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/Merging_SE_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Merging list of SummarizedExperiment objects. — Merging_SE_list","title":"Merging list of SummarizedExperiment objects. — Merging_SE_list","text":"function wrapper .(\"cbind\", se).","code":""},{"path":"https://costalab.github.io/sigurd/reference/Merging_SE_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merging list of SummarizedExperiment objects. — Merging_SE_list","text":"","code":"Merging_SE_list(se)"},{"path":"https://costalab.github.io/sigurd/reference/Merging_SE_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merging list of SummarizedExperiment objects. — Merging_SE_list","text":"se SummarizedExperiment object","code":""},{"path":"https://costalab.github.io/sigurd/reference/RowWiseSplit.html","id":null,"dir":"Reference","previous_headings":"","what":"RowWiseSplit — RowWiseSplit","title":"RowWiseSplit — RowWiseSplit","text":"Performing correlation Fisher test association SummarizedExperiment object requires extreme amounts memory. reduce amount memory necessary, instead get individual rows consensus assay. can remove NoCalls (reads) individual vectors, reducing amount memory needed. NoCalls removed, repective cells also removed different assay selected.","code":""},{"path":"https://costalab.github.io/sigurd/reference/RowWiseSplit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RowWiseSplit — RowWiseSplit","text":"","code":"RowWiseSplit(   se,   n_cores = 1,   assay_to_split = \"consensus\",   remove_nocalls = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/RowWiseSplit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RowWiseSplit — RowWiseSplit","text":"se SummarizedExperiment object. n_cores Number cores use. assay_to_split assay want split? remove_nocalls want remove NoCall cells?","code":""},{"path":"https://costalab.github.io/sigurd/reference/SeparatingMatrixToList.html","id":null,"dir":"Reference","previous_headings":"","what":"SeparatingMatrixToList — SeparatingMatrixToList","title":"SeparatingMatrixToList — SeparatingMatrixToList","text":"separate matrix variant information list. variant entry list. NoCalls (cells reads covering variant) can removed. function gets called RowWiseSplit return.","code":""},{"path":"https://costalab.github.io/sigurd/reference/SeparatingMatrixToList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SeparatingMatrixToList — SeparatingMatrixToList","text":"","code":"SeparatingMatrixToList(   row_use,   total_matrix,   consensus,   assay_to_split = \"consensus\",   remove_nocalls = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/SeparatingMatrixToList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SeparatingMatrixToList — SeparatingMatrixToList","text":"row_use row separate. total_matrix matrix split. assay_to_split assay splitting? remove_nocalls want remove NoCall cells?","code":""},{"path":"https://costalab.github.io/sigurd/reference/SetVariantInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"SetVariantInfo — SetVariantInfo","title":"SetVariantInfo — SetVariantInfo","text":"add genotyping information set variants Seurat object. function returns Seurat object values specified assay added meta data.","code":""},{"path":"https://costalab.github.io/sigurd/reference/SetVariantInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetVariantInfo — SetVariantInfo","text":"","code":"SetVariantInfo(   SE,   seurat_object,   information = \"consensus\",   variants = NULL,   consensus_character = TRUE,   consensus_group = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/SetVariantInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetVariantInfo — SetVariantInfo","text":"SE SummarizedExperiment object. seurat_object Seurat object. information assay desired information. Default: consensus variants vector variants. consensus_character consensus information save character value? consensus_group consensus groups Alt merged? effect information consensus.","code":""},{"path":"https://costalab.github.io/sigurd/reference/UMIQC.html","id":null,"dir":"Reference","previous_headings":"","what":"UMIQC — UMIQC","title":"UMIQC — UMIQC","text":"load molecule_info.h5 file CellRanger plot molecules rank. molecule defined combination UMI CB. molecules ranked number replicates.","code":""},{"path":"https://costalab.github.io/sigurd/reference/UMIQC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UMIQC — UMIQC","text":"","code":"UMIQC(   central_input_file = NULL,   molecule_info_path = NULL,   subset_by_cbs = TRUE,   cellbarcodes_path = NULL,   umi_length = 12,   min_reads = 100,   sep = \",\",   samples_column = \"sample\",   molecule_info_column = \"molecule_info\",   cellbarcode_column = \"cells\",   add_10x_suffix = \"-1\" )"},{"path":"https://costalab.github.io/sigurd/reference/UMIQC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UMIQC — UMIQC","text":"central_input_file Path csv file samples loaded. molecule_info_path Path single molecule_info file. subset_by_cbs list cell barcodes molecule_info.h5 file subset list approved cell barcodes? Default: TRUE cellbarcodes_path Path cell barcodes file. used central input file used. umi_length length UMI. Default = 12 min_reads minimum number reads per molecule. sep separator used samples_file. Default: \",\" samples_column column samples samples_file. Default: \"sample\" molecule_info_column column paths molecule_info files samples_file. Default: \"molecule_info\" cellbarcode_column column paths cell barcodes files central input file. Default: \"cells\" add_10x_suffix suffix added cell barcodes? Default 10X standard: \"-1\"","code":""},{"path":"https://costalab.github.io/sigurd/reference/UMI_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"UMI_seq — UMI_seq","title":"UMI_seq — UMI_seq","text":"function converts numeric UMI representation found 10X molecule_info.h5 file character string.","code":""},{"path":"https://costalab.github.io/sigurd/reference/UMI_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UMI_seq — UMI_seq","text":"","code":"UMI_seq(number, umi_length = 12)"},{"path":"https://costalab.github.io/sigurd/reference/UMI_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UMI_seq — UMI_seq","text":"number numeric expression UMI. umi_length length UMI. Default = 12","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantBurden.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantBurden — VariantBurden","title":"VariantBurden — VariantBurden","text":"Calculate variant burden per cell. simply sum MAF values per cell.","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantBurden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantBurden — VariantBurden","text":"","code":"VariantBurden(se)"},{"path":"https://costalab.github.io/sigurd/reference/VariantBurden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantBurden — VariantBurden","text":"se SummarizedExperiment object","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantCloneSizeThresholding.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantCloneSizeThresholding — VariantCloneSizeThresholding","title":"VariantCloneSizeThresholding — VariantCloneSizeThresholding","text":"get variants interest using clone size thresholding. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantCloneSizeThresholding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantCloneSizeThresholding — VariantCloneSizeThresholding","text":"","code":"VariantCloneSizeThresholding(   SE,   min_coverage = 2,   fraction_negative_cells = 0.9,   min_clone_size = 10,   vaf_threshold = 0.5,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantCloneSizeThresholding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantCloneSizeThresholding — VariantCloneSizeThresholding","text":"SE SummarizedExperiment object. min_coverage Minimum coverage variant needs . fraction_negative_cells fraction negative cells needed. min_clone_size minimum number cells. vaf_threshold Variant Allele Threshold. Cells threshold considered mutated. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantCorrelationHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantCorrelationHeatmap — VariantCorrelationHeatmap","title":"VariantCorrelationHeatmap — VariantCorrelationHeatmap","text":"generate heatmap showing correlation somatic variants MT variants. Packages want remove. see used. ggplot2 parallel rcompanion tidyr","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantCorrelationHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantCorrelationHeatmap — VariantCorrelationHeatmap","text":"","code":"VariantCorrelationHeatmap(   correlation_results,   output_path = NULL,   patient,   min_alt_cells = 5,   min_correlation = 0.5,   width_use = 2000,   height_use = 2000,   padding_use = c(165, 165, 2, 2),   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantCorrelationHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantCorrelationHeatmap — VariantCorrelationHeatmap","text":"correlation_results Data.frame correlation results. output_path Path output folder. patient patient heatmap. min_alt_cells Minimum number mutated cells needed, otherwise correlation plotted. min_correlation Minimum correlation needed. width_use Width heatmap px. height_use Height heatmap px. padding_use Space around heatmap mm. low, variant names might cut . verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantFisherTestHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantFisherTestHeatmap — VariantFisherTestHeatmap","title":"VariantFisherTestHeatmap — VariantFisherTestHeatmap","text":"generate heatmap showing Fisher test somatic variants MT variants. Packages want remove.","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantFisherTestHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantFisherTestHeatmap — VariantFisherTestHeatmap","text":"","code":"VariantFisherTestHeatmap(   fisher_results,   patient,   min_alt_cells = 5,   min_oddsratio = 1,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantFisherTestHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantFisherTestHeatmap — VariantFisherTestHeatmap","text":"fisher_results Data.frame correlation results. patient patient heatmap. min_alt_cells Minimum number mutated cells needed, otherwise association plotted. min_oddsratio Minimum correlation needed. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantQuantileThresholding_Combined.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantQuantileThresholding_Combined — VariantQuantileThresholding_Combined","title":"VariantQuantileThresholding_Combined — VariantQuantileThresholding_Combined","text":"get variants interest using quantile thresholding. function combines functions VariantSelection_Quantile, VariantSelection_Group VariantSelection_TopCells. use top_cells top_VAF, supply one quantil value (quantiles = 0.9, thresholds = 0). function adapted Peter van Galen. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantQuantileThresholding_Combined.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantQuantileThresholding_Combined — VariantQuantileThresholding_Combined","text":"","code":"VariantQuantileThresholding_Combined(   SE,   min_coverage = 2,   quantiles = c(0.1, 0.9),   thresholds = c(0.1, 0.9),   top_cells = NULL,   top_VAF = NULL,   min_quality = NULL,   mean_allele_frequency = 0,   group_of_interest = NULL,   group1 = NULL,   group2 = NULL,   group_factor = NULL,   remove_nocall = TRUE,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantQuantileThresholding_Combined.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantQuantileThresholding_Combined — VariantQuantileThresholding_Combined","text":"SE SummarizedExperiment object. min_coverage Minimum coverage needed. quantiles lower upper quantile want use. thresholds VAF thresholds want use quantiles. top_cells number cells least top_VAF percent variant. top_VAF VAF top cells. min_quality minimum quality want Variants Interest. Can ignored setting NULL. mean_allele_frequency minimum mean allele frequency. Default = 0 group_of_interest column data divides cells. group1 first group interest. set, quantiles calculated group. group2 second group interest. group_factor much higher mean allele frequency group 1 compared group 2? remove_nocall NoCall cells (consensus = 0) disregarded analysis? verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_Group.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantSelection_Group — VariantSelection_Group","title":"VariantSelection_Group — VariantSelection_Group","text":"get variants interest selecting variants high VAF difference two groups. function adapted Peter van Galen. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_Group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantSelection_Group — VariantSelection_Group","text":"","code":"VariantSelection_Group(   SE,   min_coverage = 2,   quantiles = c(0.1, 0.9),   thresholds = c(0.1, 0.9),   min_quality = NULL,   mean_allele_frequency = 0,   group_of_interest = NULL,   group1 = NULL,   group2 = NULL,   group_factor = 5,   remove_nocall = TRUE,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_Group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantSelection_Group — VariantSelection_Group","text":"SE SummarizedExperiment object. min_coverage Minimum coverage needed. quantiles lower upper quantile want use. thresholds VAF thresholds want use quantiles. min_quality minimum quality want Variants Interest. Can ignored setting NULL. mean_allele_frequency minimum mean allele frequency. Default = 0 group_of_interest column data divides cells. group1 first group interest. set, quantiles calculated group. group2 second group interest. group_factor much higher mean allele frequency group 1 compared group 2? remove_nocall NoCall cells (consensus = 0) disregarded analysis? verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_Quantile.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantSelection_Quantile — VariantSelection_Quantile","title":"VariantSelection_Quantile — VariantSelection_Quantile","text":"get variants interest using quantile thresholding. function adapted Peter van Galen. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_Quantile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantSelection_Quantile — VariantSelection_Quantile","text":"","code":"VariantSelection_Quantile(   SE,   min_coverage = 2,   quantiles = c(0.1, 0.9),   thresholds = c(0.1, 0.9),   min_quality = NULL,   mean_allele_frequency = 0,   remove_nocall = FALSE,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_Quantile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantSelection_Quantile — VariantSelection_Quantile","text":"SE SummarizedExperiment object. min_coverage Minimum coverage needed. quantiles lower upper quantile want use. thresholds VAF thresholds want use quantiles. min_quality minimum quality want Variants Interest. Can ignored setting NULL. mean_allele_frequency minimum mean allele frequency. Default = 0 remove_nocall NoCall cells (consensus = 0) disregarded analysis? verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_TopCells.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantSelection_TopCells — VariantSelection_TopCells","title":"VariantSelection_TopCells — VariantSelection_TopCells","text":"get variants interest selecting small number cells high VAF variant. function adapted Peter van Galen. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_TopCells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantSelection_TopCells — VariantSelection_TopCells","text":"","code":"VariantSelection_TopCells(   SE,   min_coverage = 2,   quantiles = 0.9,   thresholds = 0,   top_cells = 10,   top_VAF = 0.5,   min_quality = NULL,   remove_nocall = TRUE,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_TopCells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantSelection_TopCells — VariantSelection_TopCells","text":"SE SummarizedExperiment object. min_coverage Minimum coverage needed. quantiles lower upper quantile want use. thresholds VAF thresholds want use quantiles. min_quality minimum quality want Variants Interest. Can ignored setting NULL. remove_nocall NoCall cells (consensus = 0) disregarded analysis? verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_VMR.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantSelection_VMR — VariantSelection_VMR","title":"VariantSelection_VMR — VariantSelection_VMR","text":"adaption VMR based selection variants Miller et al.  selection process designed ATAC data scRNAseq data.","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_VMR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantSelection_VMR — VariantSelection_VMR","text":"","code":"VariantSelection_VMR(   SE,   stabilize_variance = TRUE,   low_coverage_threshold = 10,   minimum_fw_rev_reads = 2,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_VMR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantSelection_VMR — VariantSelection_VMR","text":"SE SummarizedExperiment object. stabilize_variance variance stabilized using mean allele frequency cells low coverage? Coverage threshold set low_coverage_threshold. low_coverage_threshold Cells threshold set mean. minimum_fw_rev_reads many forward reverse reads cell ? Default = 2 verbose function verbose?","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_VMR_Group.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantSelection_VMR_Group — VariantSelection_VMR_Group","title":"VariantSelection_VMR_Group — VariantSelection_VMR_Group","text":"adaption VMR based selection variants Miller et al.  selection process designed ATAC data scRNAseq data.  variants first selected described. average allele frequency two groups interest compared. allele frequency group1 higher required threshold, variant retained.","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_VMR_Group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantSelection_VMR_Group — VariantSelection_VMR_Group","text":"","code":"VariantSelection_VMR_Group(   SE,   stabilize_variance = TRUE,   low_coverage_threshold = 10,   minimum_fw_rev_reads = 2,   group_of_interest = NULL,   group1 = NULL,   group2 = NULL,   group_factor = 5,   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantSelection_VMR_Group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantSelection_VMR_Group — VariantSelection_VMR_Group","text":"SE SummarizedExperiment object. stabilize_variance variance stabilized using mean allele frequency cells low coverage? Coverage threshold set low_coverage_threshold. low_coverage_threshold Cells threshold set mean. minimum_fw_rev_reads many forward reverse reads cell ? Default = 2 group_of_interest group interest column data. group1 group interest. group2 second group. group_factor much higher VAF group 1 comapred group 2? Default = 5 verbose function verbose?","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantWiseCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantWiseCorrelation — VariantWiseCorrelation","title":"VariantWiseCorrelation — VariantWiseCorrelation","text":"correlate variants using Pearson correlation. function calls CalculateCorrelationPValue perform actual correlation.","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantWiseCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantWiseCorrelation — VariantWiseCorrelation","text":"","code":"VariantWiseCorrelation(   variants_list,   n_cores = 1,   p_value_adjustment = \"fdr\",   value_type = \"consensus\",   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantWiseCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantWiseCorrelation — VariantWiseCorrelation","text":"variants_list List fraction values. n_cores Number cores want use. Numeric. p_value_adjustment Method P value adjustment. See p.adjust details. value_type using consensus information? verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantWiseFisherTest.html","id":null,"dir":"Reference","previous_headings":"","what":"VariantWiseFisherTest — VariantWiseFisherTest","title":"VariantWiseFisherTest — VariantWiseFisherTest","text":"perform Fisher test determine variants associated. function calls CalculateFisherTestPValue perform actual testing.","code":""},{"path":"https://costalab.github.io/sigurd/reference/VariantWiseFisherTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VariantWiseFisherTest — VariantWiseFisherTest","text":"","code":"VariantWiseFisherTest(   variants_list,   n_cores = 1,   p_value_adjustment = \"fdr\",   verbose = TRUE )"},{"path":"https://costalab.github.io/sigurd/reference/VariantWiseFisherTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VariantWiseFisherTest — VariantWiseFisherTest","text":"variants_list List fraction values. n_cores Number cores want use. Numeric. p_value_adjustment Method P value adjustment. See p.adjust details. verbose function verbose? Default = TRUE","code":""},{"path":"https://costalab.github.io/sigurd/reference/char_to_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"char_to_numeric — char_to_numeric","title":"char_to_numeric — char_to_numeric","text":"function convert heterozygous/homozygous information VCF consensus information VarTrix. used LoadingVCF_typewise.R.","code":""},{"path":"https://costalab.github.io/sigurd/reference/char_to_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"char_to_numeric — char_to_numeric","text":"","code":"char_to_numeric(char_value)"},{"path":"https://costalab.github.io/sigurd/reference/char_to_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"char_to_numeric — char_to_numeric","text":"char_value genotype encoding want convert?","code":""},{"path":"https://costalab.github.io/sigurd/reference/combine_NAMES.html","id":null,"dir":"Reference","previous_headings":"","what":"combine_NAMES — combine_NAMES","title":"combine_NAMES — combine_NAMES","text":"combine two vectors names.","code":""},{"path":"https://costalab.github.io/sigurd/reference/combine_NAMES.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"combine_NAMES — combine_NAMES","text":"","code":"combine_NAMES(x, y)"},{"path":"https://costalab.github.io/sigurd/reference/combine_NAMES.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"combine_NAMES — combine_NAMES","text":"x First vector names. y Second vector names.","code":""},{"path":"https://costalab.github.io/sigurd/reference/combine_SparseMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"combine_sparseMatrix — combine_SparseMatrix","title":"combine_sparseMatrix — combine_SparseMatrix","text":"combine two sparse matrices","code":""},{"path":"https://costalab.github.io/sigurd/reference/combine_SparseMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"combine_sparseMatrix — combine_SparseMatrix","text":"","code":"combine_SparseMatrix(matrix_1, matrix_2)"},{"path":"https://costalab.github.io/sigurd/reference/combine_SparseMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"combine_sparseMatrix — combine_SparseMatrix","text":"matrix_1 first sparse matrix. matrix_2 second matrix.","code":""},{"path":"https://costalab.github.io/sigurd/reference/computeAFMutMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"computeAFMutMatrix — computeAFMutMatrix","title":"computeAFMutMatrix — computeAFMutMatrix","text":"Calculate allele frequency per variant. Source: https://github.com/petervangalen/MAESTER-2021 can get AF values greater 1, due uninformative reads. See: https://gatk.broadinstitute.org/hc/en-us/articles/360035532252-Allele-Depth-AD--lower--expected https://github.com/caleblareau/mgatk/issues/1 simply set values 1, since actual information case.","code":""},{"path":"https://costalab.github.io/sigurd/reference/computeAFMutMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeAFMutMatrix — computeAFMutMatrix","text":"","code":"computeAFMutMatrix(SE, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/computeAFMutMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeAFMutMatrix — computeAFMutMatrix","text":"SE SummarizedExperiment object. chromosome_prefix prefix chromosome.","code":""},{"path":"https://costalab.github.io/sigurd/reference/getAltMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"getAltMatrix — getAltMatrix","title":"getAltMatrix — getAltMatrix","text":"get alt values MAEGATK results. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/getAltMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getAltMatrix — getAltMatrix","text":"","code":"getAltMatrix(SE_object, letter, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/getAltMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getAltMatrix — getAltMatrix","text":"SE_object SummarizedExperiment object. letter base want use. Character. chromosome_prefix chromosome prefix used.","code":""},{"path":"https://costalab.github.io/sigurd/reference/getMutMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"getMutMatrix — getMutMatrix","title":"getMutMatrix — getMutMatrix","text":"function gets allele frequency specific allele. used computeAFMutMatrix. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/getMutMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getMutMatrix — getMutMatrix","text":"","code":"getMutMatrix(SE, cov, letter, ref_allele, chromosome_prefix)"},{"path":"https://costalab.github.io/sigurd/reference/getMutMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getMutMatrix — getMutMatrix","text":"SE SummarizedExperiment object. cov coverage matrix MAEGATK/MGATK. letter base interested . ref_allele Vector reference alleles. chromosome_prefix chromosome prefix used.","code":""},{"path":"https://costalab.github.io/sigurd/reference/getReadMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the counts for a specific base over all positions. — getReadMatrix","title":"Get the counts for a specific base over all positions. — getReadMatrix","text":"Get counts specific base positions.","code":""},{"path":"https://costalab.github.io/sigurd/reference/getReadMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the counts for a specific base over all positions. — getReadMatrix","text":"","code":"getReadMatrix(SE, letter, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/getReadMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the counts for a specific base over all positions. — getReadMatrix","text":"SE SummarizedExperiment object. letter base want counts. chromosome_prefix chromosome name used prefix.","code":""},{"path":"https://costalab.github.io/sigurd/reference/getRefMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"getRefMatrix — getRefMatrix","title":"getRefMatrix — getRefMatrix","text":"get reference values MAEGATK result. Source: https://github.com/petervangalen/MAESTER-2021","code":""},{"path":"https://costalab.github.io/sigurd/reference/getRefMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getRefMatrix — getRefMatrix","text":"","code":"getRefMatrix(SE_object, letter, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/getRefMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getRefMatrix — getRefMatrix","text":"SE_object SummarizedExperiment object. letter base analysing. get matrix shows cells many reference reads letter. chromosome_prefix chromosome prefix used.","code":""},{"path":"https://costalab.github.io/sigurd/reference/get_consensus.html","id":null,"dir":"Reference","previous_headings":"","what":"get_consensus — get_consensus","title":"get_consensus — get_consensus","text":"get consensus information specific matrix. want remove packages needed. See package apperantly needed.","code":""},{"path":"https://costalab.github.io/sigurd/reference/get_consensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get_consensus — get_consensus","text":"","code":"get_consensus(alt_base, ref_base, input_matrix, chromosome_prefix = \"chrM\")"},{"path":"https://costalab.github.io/sigurd/reference/get_consensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get_consensus — get_consensus","text":"alt_base alternative base. ref_base reference base. input_matrix Input matrix present reads numerically encoded. chromosome_prefix chromosome name used prefix.","code":""},{"path":"https://costalab.github.io/sigurd/reference/load_object.html","id":null,"dir":"Reference","previous_headings":"","what":"load_object — load_object","title":"load_object — load_object","text":"loading function load RDS files quicker. Source: https://github.com/CostaLab/CimpleG","code":""},{"path":"https://costalab.github.io/sigurd/reference/load_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"load_object — load_object","text":"","code":"load_object(file_name)"},{"path":"https://costalab.github.io/sigurd/reference/load_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"load_object — load_object","text":"file_name path file.","code":""},{"path":"https://costalab.github.io/sigurd/reference/save_object.html","id":null,"dir":"Reference","previous_headings":"","what":"save_object — save_object","title":"save_object — save_object","text":"Saving function save RDS files quicker. Source:https://github.com/CostaLab/CimpleG","code":""},{"path":"https://costalab.github.io/sigurd/reference/save_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"save_object — save_object","text":"","code":"save_object(object, file_name, file_format = \"zstd\")"},{"path":"https://costalab.github.io/sigurd/reference/save_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"save_object — save_object","text":"object R object save. file_name path file shall save. file_format format save file. one : zstd, lz4, gzip, bzip2, xz, nocomp.","code":""},{"path":"https://costalab.github.io/sigurd/reference/sdiv.html","id":null,"dir":"Reference","previous_headings":"","what":"Division of sparse matrix. — sdiv","title":"Division of sparse matrix. — sdiv","text":"Division sparse matrix.","code":""},{"path":"https://costalab.github.io/sigurd/reference/sdiv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Division of sparse matrix. — sdiv","text":"","code":"sdiv(X, Y, names = dimnames(X))"},{"path":"https://costalab.github.io/sigurd/reference/sdiv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Division of sparse matrix. — sdiv","text":"X First sparse matrix. Y Second sparse matrix. names dimension names (dimnames(X)).","code":""}]
